---
title: "GSE99249: ADAR1 KO 293FT"
author: Kent Riemondy
date: "2023-05-22"
output:
    BiocStyle::html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(glue)
library(Rsamtools)
```

## Obtaining fastq files

FASTQ files will be downloaded using the fasterq-dump command-line tool from the sratoolkit.

```{r}
sra_ids <- c("SRR5564260",
             "SRR5564261",
             "SRR5564269",
             "SRR5564270",
             "SRR5564271",
             "SRR5564277")

#sra_ids <- c("SRR5564277")

fq_suffixes <- paste0("_", 1:2, ".fastq")
fq_files <- list()

for(i in seq_along(sra_ids)) {
    sra_id <- sra_ids[i]
    dir.create(file.path("GSE99249", sra_id), recursive = TRUE, showWarnings = FALSE)
    outfiles <- file.path("GSE99249", sra_id, paste0(sra_id, fq_suffixes))
    fq_files[[sra_id]] <- outfiles
        
    if(all(file.exists(outfiles))) next;
    
    message("downloading sra id: ", sra_id)
    rc <- system(paste("fasterq-dump -S -O", file.path("GSE99249", sra_id),  sra_id))
    stopifnot(rc == 0L)
}
```


## Read alignment

Reads are next aligned to the genome using STAR supplemented with splice junctions defined for the hg38 genome. The STAR index and gene annotations in GTF format were generated using the script provided at `inst/dbases/get_databases.sh`.

```{r}
star_idx <- "dbases/star/GRCh38"
gtf <- "dbases/gencode.v37.annotation.gtf"
star_bam_files <- list()

for(i in seq_along(sra_ids)){

    sra_id <- sra_ids[[i]]
    r1 <- fq_files[[sra_id]][1]
    r2 <- fq_files[[sra_id]][2]
    out_prefix <- file.path("GSE99249", sra_id, paste0(sra_id, "_"))
    tmp_bam_file <- paste0(out_prefix, "Aligned.out.bam")
    srted_bam_file <- paste0(out_prefix, "sorted")
    message("aligning sra_id: ", sra_id)
    
    star_cmd <- glue("STAR",
                     "--genomeDir {star_idx}",
                     "--sjdbGTFfile {gtf}",
                     "--runThreadN 12",
                     "--readFilesIn {r1} {r2}",
                     "--outFileNamePrefix {out_prefix}",
                     "--outSAMattributes NH HI AS nM MD",
                     "--outSAMtype BAM Unsorted",
                     "--outFilterType BySJout",
                     "--alignSJoverhangMin 8",
                     "--alignSJDBoverhangMin 2",
                     "--outFilterMismatchNoverLmax 0.04",
                     "--alignIntronMin 20",
                     "--alignIntronMax 1000000",
                     "--alignMatesGapMax 1000000", 
                     .sep = " ")
    rc <- system(star_cmd)
    stopifnot(rc == 0L)
    
    out_bam <- sortBam(tmp_bam_file, srted_bam_file)
    unlink(tmp_bam_file)
    
    star_bam_files[[sra_id]] <- out_bam
}
```

# Identify duplicate reads

Duplicate reads are next identified using `MarkDuplicates` from picard, and bam file index files generated from final output bam files.

```{r}
for(i in seq_along(sra_ids)){
    sra_id <- sra_ids[[i]]
    inbam <- bam_files[[sra_id]]
    outbam <- file.path(sra_id, ".bam")
    picard_cmd <- glue("picard MarkDuplicates", 
                       "-Xms2g -Xmx8g -XX:ParallelGCThreads=2",
                       "-I {inbam}",
                       "--MAX_FILE_HANDLES_FOR_READ_ENDS_MAP 1000",
                       "-O {outbam}",
                       "--REMOVE_DUPLICATES false",
                       "--CREATE_INDEX false",
                       "--VALIDATION_STRINGENCY SILENT",
                       .sep = " ")
    
    indexBam(outbam)
}
```

# Clean up

Unneeded temporary files are next deleted, keeping only the bam and bam index files. 

```{r}
unlink(sra_ids, recursive = TRUE)
```


<details><summary>Show session info</summary>

```{r code}
sessionInfo()
```
</details>
